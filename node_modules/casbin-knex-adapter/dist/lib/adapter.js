Object.defineProperty(exports, "__esModule", { value: true });
exports.KnexAdapter = void 0;
const casbin_1 = require("casbin");
const utils_1 = require("./utils");
class KnexAdapter {
    constructor(knex, options) {
        this.knex = knex;
        this.tableName = (options === null || options === void 0 ? void 0 : options.tableName) || 'policies';
        this.chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || 100;
        this.concurrentDeletes = (options === null || options === void 0 ? void 0 : options.concurrentDeletes) || 5;
    }
    static async newAdapter(knex, options) {
        const adapter = new KnexAdapter(knex, options);
        await adapter.createTable();
        return adapter;
    }
    get policiesTable() {
        return this.knex(this.tableName);
    }
    async createTable() {
        const tableExists = await this.knex.schema.hasTable(this.tableName);
        if (!tableExists) {
            await this.knex.schema.createTable(this.tableName, (table) => {
                table.increments('id').primary();
                table.string('ptype').nullable();
                table.string('v0').nullable();
                table.string('v1').nullable();
                table.string('v2').nullable();
                table.string('v3').nullable();
                table.string('v4').nullable();
                table.string('v5').nullable();
            });
        }
    }
    async dropTable() {
        await this.knex.schema.dropTableIfExists(this.tableName);
    }
    async close() {
        await this.knex.destroy();
    }
    async loadPolicy(model) {
        const policies = await this.policiesTable.select();
        for (const policy of policies) {
            loadPolicyLine(policy, model);
        }
    }
    async savePolicy(model) {
        try {
            await this.dropTable();
            await this.createTable();
            const pPolicies = createPoliciesFromAstMap(model.model.get('p'));
            const gPolicies = createPoliciesFromAstMap(model.model.get('g'));
            const combinedPolicies = [...pPolicies, ...gPolicies];
            if (combinedPolicies.length > 0) {
                await this.policiesTable.insert(combinedPolicies);
            }
            return true;
        }
        catch (err) {
            return false;
        }
    }
    async addPolicy(sec, ptype, rule) {
        const policy = createPolicy(ptype, rule);
        await this.policiesTable.insert(policy);
    }
    async addPolicies(sec, ptype, rules) {
        const policies = rules.map((rule) => {
            return createPolicy(ptype, rule);
        });
        const insertChunks = utils_1.chunk(policies, this.chunkSize);
        for (const insertChunk of insertChunks) {
            await this.policiesTable.insert(insertChunk);
        }
    }
    async removePolicy(sec, ptype, rule) {
        const policy = createPolicy(ptype, rule);
        await this.policiesTable.delete().where(policy);
    }
    async removePoliciesWhere(whereParam) {
        await this.policiesTable.delete().where(whereParam);
    }
    async removePolicies(sec, ptype, rules) {
        const deleteChunks = utils_1.chunk(rules, this.concurrentDeletes);
        for (const chunk of deleteChunks) {
            const promises = chunk.map((rule) => {
                return this.removePolicy(sec, ptype, rule);
            });
            await Promise.all(promises);
        }
    }
    async removeFilteredPolicy(sec, ptype, fieldIndex, ...fieldValues) {
        const filteredPolicy = createFilteredPolicy(ptype, fieldIndex, ...fieldValues);
        await this.policiesTable.delete().where(filteredPolicy);
    }
}
exports.KnexAdapter = KnexAdapter;
function loadPolicyLine(policy, model) {
    const policyLine = policy.ptype +
        ', ' +
        [policy.v0, policy.v1, policy.v2, policy.v3, policy.v4, policy.v5]
            .filter((v) => v)
            .join(', ');
    casbin_1.Helper.loadPolicyLine(policyLine, model);
}
function createPolicy(ptype, rule) {
    if (rule.length === 3) {
        return {
            ptype,
            v0: rule[0],
            v1: rule[1],
            v2: rule[2],
        };
    }
    return rule.reduce((acc, value, index) => {
        acc[`v${index}`] = rule[index];
        return acc;
    }, { ptype });
}
function createPoliciesFromAstMap(astMap) {
    const policies = [];
    if (!astMap) {
        return policies;
    }
    for (const [ptype, ast] of astMap) {
        for (const rule of ast.policy) {
            policies.push(createPolicy(ptype, rule));
        }
    }
    return policies;
}
function createFilteredPolicy(ptype, fieldIndex, ...fieldValues) {
    const filteredPolicy = { ptype };
    if (fieldIndex <= 0 && 0 < fieldIndex + fieldValues.length) {
        filteredPolicy.v0 = fieldValues[0 - fieldIndex];
    }
    if (fieldIndex <= 1 && 1 < fieldIndex + fieldValues.length) {
        filteredPolicy.v1 = fieldValues[1 - fieldIndex];
    }
    if (fieldIndex <= 2 && 2 < fieldIndex + fieldValues.length) {
        filteredPolicy.v2 = fieldValues[2 - fieldIndex];
    }
    if (fieldIndex <= 3 && 3 < fieldIndex + fieldValues.length) {
        filteredPolicy.v3 = fieldValues[3 - fieldIndex];
    }
    if (fieldIndex <= 4 && 4 < fieldIndex + fieldValues.length) {
        filteredPolicy.v4 = fieldValues[4 - fieldIndex];
    }
    if (fieldIndex <= 5 && 5 < fieldIndex + fieldValues.length) {
        filteredPolicy.v5 = fieldValues[5 - fieldIndex];
    }
    return filteredPolicy;
}
